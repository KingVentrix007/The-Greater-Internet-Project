
# HTTPE and EDOI Protocol Specification v1.0

## Overview

This document outlines the specifications for the **HTTPE** (HyperText Transport Protocol Encrypted) and **EDOI** (Encrypted Data Over Internet) protocols.

- **HTTPE** is the main protocol used to send encrypted requests and responses between client and server.
- **EDOI** is used by HTTPE to handle encryption, key exchange, and token management.

---

## HTTPE Protocol

### Request Format

```
VERSION: HTTPE/1.0
METHOD: GET | POST
TYPE: REQ_ENC(Defualt post handshake) | GET_RSA | SHARE_AES (optional, used by EDOI)
ID: RSA-Encrypted UUID (optional unless TYPE = SHARE_AES)
TOKEN: AES-Encypted token(optional unless TYPE = REQ_ENC)
LOCATION: /path/to/resource
HEADERS:
  is_com_setup: true | false
  client_id: UUID or None
  packet_id: UUID
  timestamp: ISO 8601 format (e.g., datetime.now(timezone.utc).isoformat())
  compressions: true | false (not implemented yet)
END
[POST DATA - assumed to be JSON unless specified otherwise]
```

### Special Method Handling

- `METHOD` is always treated as `POST` during `GET_RSA` and `SHARE_AES` for formatting purposes only.
- `TYPE: GET_RSA` and `TYPE: SHARE_AES` should **not** access endpoints but instead trigger internal server-side setup routines.
- If `TYPE = REQ_ENC`, the values of `LOCATION`, `HEADERS`, and `METHOD` are AES-encrypted.

---

## EDOI Protocol

### EDOI v1 (Deprecated)

#### Handshake Sequence

1. Client requests the server’s RSA key (and certificate), verifying with a pre-shared key.
2. Client sends AES key and user ID (UUIDv4), both RSA-encrypted.
3. All subsequent requests must include `TYPE: REQ_ENC` and RSA-encrypted `ID`.
4. `LOCATION`, `METHOD`, and `HEADERS` are AES-encrypted. `VERSION` and `TYPE` are not.
5. Server responses to `REQ_ENC` must be AES-encrypted (not implemented in demo).

### EDOI v2 (Recommended)

#### Handshake Sequence

1. Client requests the server’s RSA key and certificate (same as v1).
2. Client sends AES key and user ID (UUIDv4), both RSA-encrypted.
3. Server sends back an AES-encrypted token containing:
    - Decrypted client ID
    - Timestamp
    - Server-generated session ID
3.1. Server sends back certifcate with token for client verification

#### Token-Based Requests

- Token replaces `ID` in future requests.
- Token is encrypted with the server’s **master AES key** (per runtime or persistent).
- Server compares token ID with `client_id` in header. Mismatch invalidates the session.

---

## Token Structure

- `client_id`: From the user during Step 2
- `server_id`: Generated by the server
- `timestamp`: ISO 8601

The entire token is encrypted using the server’s master AES key.

### Recommendations

- Client should store encrypted `client_id`, `ID`, AES key, and RSA key in session storage (for EDOI v1 only).
- Store tokens per user session.
- Client must regenerate `ID` (UUIDv4) each session.
- AES key must not persist beyond session.
- Server may enforce token expiration (demo uses 20 minutes).

### Connection Requirements

Connection is rejected if:
- `packet_id` is missing or duplicate
- `timestamp` is missing or older than 2 minutes
- `client_id` is unknown or does not match token ID
- Token is stolen or reused from another session
- Compression must occur **before** encryption and is skipped during handshake

### Token Theft Detection

- If token’s `client_id` ≠ header’s `client_id`, invalidate connection.
- Log the token, disconnect any matching session, and require a full reconnect.

---

## Cryptography

- **RSA:** 2048-bit (used during handshake only)
- **AES:** 128-bit (Fernet-based in current demo)
- **UUIDs:** Version 4 for all IDs

### Notes

- All AES operations currently use `Fernet` in Python.
- RSA is used **only** during handshake.
- Token is encrypted using server’s master AES key.
- Request body is encrypted using a separate client-generated AES key.
- If token and header IDs do not match, connection is terminated.

---

## Valid Packet Types

- `GET_RSA`
- `SHARE_AES`
- `REQ_ENC`
- `REQ_END`

> Note: After exchanging a token, the `ID` in the pre-header is no longer sent. Validation uses the token's internal ID and the `client_id` from headers.

---

## Future Work

- Error codes
- Compression algorithms
- Lease expiration and connection auto-termination
- Complete encrypted response handling

